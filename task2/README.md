# Typescript 타입 정리하기

```
* 미리 정리

  리터럴(literal)
    - 코드 상에서 값 그 자체를 나타내는 표기법.!
    - 사람들 끼리 미리 약속된 기호.!

  문자열 리터럴: 큰 따옴표, 혹은 작은 따옴표 내부의 값
    ex) `"Hello, World!"` , `'Hello, World!'`

  숫자 리터럴: 
    ex) `0` , `-2` , `3.14`

  이진 리터럴: `0b` 를 접두사로 사용
    ex) `0b101010`

  팔진 리터럴: `0o` 를 접두사로 사용
    ex) `0o42`

```

## 주요 타입 및 관련 개념 정리
[출처: Typescript 공식문서 > Handbook](https://www.typescriptlang.org/docs/handbook/basic-types.html)

### number
- 숫자를 다루는 타입
- 해당 타입을 가진 변수는 값을 실수형(부동 소수점) 으로 관리한다. 
- 2진수, 8진수, 16진수 리터럴 역시 `number` 타입으로 표현할 수 있다.
- 일반적으로 ±9 * 10^15 까지 안전하게 표현가능하다.
- 그 이상 혹은 아주 큰 숫자에 대해서는 `bigint` 타입으로 관리할 수 있다.

### string
- 문자열 을 다루는 타입
- 큰 따옴표(""), 작은 따옴표('') 안에 있는 텍스트 데이터를 관리한다.
- 템플릿 문자열 ( 역따옴표(\`) ) 내부의 모든 텍스트 및 표현식 또한 `string` 타입으로 분류한다.

### boolean 
- 참/거짓 상태를 다루는 타입

### any
- 모든 값을 할당할 수 있다.
- 타입 정보를 확인할 수 없거나, 타입 검사에서 제외하고 싶은 값에 부여한다.
- `any` 타입의 데이터에 대해서는, Typescript-editor를 통한 자동완성 기능이 제한된다.
- `any` 타입의 객체에 대해서, 객체 내부의 요소나 메스드에 접근이 아예 불가능하지 않다. (`unknown` 타입과 비교..)
- `any` 타입 사용시, 타입 안정성이 깨지는 문제 (Javascript 의 단점) 가 다시 발생하기 때문에, Typescript 에서는 되도록 사용하지 않는 것이 좋다. 

### object
- `any` 와 비슷하게, 중괄호({}) 로 감싸진 형태의 값을 모두 할당할 수 있다.
- 객체 내부의 속성 키 혹은 속성 값의 타입이 동적으로 수정할 수 있다.

### array
- 순서대로 순회할 수 있는 구조로 값을 관리하는 배열의 타입이다.


### unknown
- 동적 컨텐츠 (third-party api 혹은 사용자로부터의 입력 등) 에 대하여 구체적인 타입이 불명확한 경우, Typescript 가 자동으로 지정해주는 타입이다.
- `any` 로 정의된 변수 혹은 객체에 대해 타입 체크를 아예 진행하지 않지만, `unknown` 으로 정의된 변수의 경우 타입확정이 되지 않은 이유로 연산 등의 대상이 되지 않는다. (compile 시, 혹은 그 이전에 오류를 확인 가능하다.)

### union
- 두 개 이상의 타입을 가진 값이 할당될 것이라고 예상될 때 사용한다.

### type alias
- 새로운 타입을 정의하는 방법이다.
- primitive-type, union, array, object 등을 활용하여 프로젝트에 필요한 타입을 생성할 수 있다.
- 다른 타입의 상속이 필요할 경우, `&` 연산자를 활용해 병합하는 방식으로 타입을 공유할 수 있다.

### interface
- 새로운 타입을 정의하는 방법이다.
- interface 로 생성한 타입은 key 값을 반드시 갖도록 설계되어야 한다.
- `extends` 키워드를 활용해서, 다른 타입으로부터 필요한 속성을 상속받을 수 있다.

### type assert
- 컴파일러가 정확히 타입을 추론하지 못할 경우, 직접 타입을 지정할 수 있다.
- 객체 혹은 변수명 뒤에 `as` 키워드와 함께 타입을 명시하면 된다.

### generics
- 함수를 정의할 때, 해당 함수에서 사용되는 타입 정보를 함수를 이용하는 측에서 외부에서 지정할 수 있도록 하는 방법이다.
- 코드 재사용성이 높아진다.
